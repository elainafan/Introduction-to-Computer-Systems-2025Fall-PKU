# 从零开始的Data Lab

> [!CAUTION]
> 
> **本笔记仅供参考，请勿抄袭。**

## 声明
本笔记的写作初衷在于，笔者在做Data Lab的时候受到Arthals学长很大启发，同时25Fall的计算机系统导论课程改制增加了10分的Lab测试（虽然往年的期中期末中也会有一两道Lab相关选择题，但分值不大）。故将心路历程写成此笔记，以便复习，并供后续选课同学参考。

## Data Lab简要介绍
Data Lab是《计算机系统导论》课程的第一个Lab，该课程使用流行的计算机基础教材《深入理解计算机系统》（又名CSAPP/~~没人理解计算机系统~~）。其Lab取材于美国卡耐基梅隆的同名课程，北京大学课程团队每年都会对Lab进行修改，导致每年的puzzle（下文会介绍）都不一样，这里仅给出思路的实现。

Data Lab对应的为教材第二章《信息的表示与处理》，主要考察对位运算的理解。在bits.c文件中，会给出16个对应的puzzle，其分值对应为1-4不等。每个puzzle会有操作符类型与操作符数量的限制，总分分为实现分与表现分，其中实现分即代码在对应操作符类型下能通过test即满分，若操作符数量超出限制即扣除一定比例表现分。总分原始分为80分，在测评后会乘1.25作为最终总分。在AutoLab上的提交次数最多不能超过16次。笔者的耗时大约在13-15小时左右。

这些puzzle包括：

位运算：

| Name                     | Description                                 | Rating  | Max ops |
| ------------------------ | ------------------------------------------- | ------- | ------- |
| bitOr (x, y)             | 仅使用 ～ 和 \& 来实现 x \| y                 | 1      | 8       |
| upperBits (n)            | 将32位二进制的高 n 位设置为1                  | 1       | 10      |
| fullAdd (x, y)           | 将 x + y 对16取模                            | 2       | 30      |
| rotateLeft (x, n)        | 将 x 的二进制表示循环左移 n 位                | 3       | 25      |
| bitParity (x)            | 判断 x 的二进制表示中是否有奇数个1             | 4       | 20     |
| palindrome (x)           | 判断 x 的二进制表示是否回文                    | 4      | 40     |

补码运算：

| Name                     | Description                                 | Rating  | Max ops |
| ------------------------ | ------------------------------------------- | ------- | ------- |
| negate (x)               | 对 x 取相反数                                | 2       | 5       |
| oneMoreThan (x, y)       | 判断 y 是否比 x 大1                          | 2       | 15      |
| ezThreeFourths (x)       | 将 x * 3/4 向零舍入                          | 3       | 12      |
| isLess (x, y)            | 判断 x 是否小于 y                            | 3       | 24      |
| satMul2 (x)              | 计算 x 乘 2 的结果                           | 3       | 20      |
| modThree (x)             | 计算 x 模 3 的结果                           | 4       | 60      |

浮点数运算：
| Name                     | Description                                 | Rating  | Max ops |
| ------------------------ | ------------------------------------------- | ------- | ------- |
| float_half (x)           | 计算 0.5 * x 的浮点表示                      | 4       | 30      |
| float_i2f (x)            | 将整数 x 转换为浮点数                         | 4        | 30    |
| float64_f2i (x)          | 将双精度浮点数 x 转换为整数                   | 4       | 20      |
| float_pwr2 (x)           | 计算 2.0 ^ x 的浮点表示                      | 4       | 30      |

我们需要在文件``bits.c``中实现这些函数。

## 在动手之前
### Linux相关
由于同学们可能是第一次接触Linux系统（事实上笔者也差不多），因此下面介绍Linux系统的相关知识。

值得庆贺的是，24秋往后的Lab完成均使用北大Linux俱乐部维护的CLab云服务器，使用专门为ICS提供的Ubuntu镜像，SSH配置也有助教指导，故忽略。

当然，如果有同学喜欢用虚拟机、双系统或者WSL完成，亦可。

下面介绍Linux系统的相关指令：

- 上传文件：``scp [本地文件] ubuntu@[ip]"[文件夹]``，亦可使用VsCode的``Remote-SSH``插件拖拽实现。
- 下载文件（到当前目录）：``scp ubuntu@[ip]:/home/...``
- 当前工作目录：``pwd``
- 当前文件夹列表：``ls``
- 进入``xxx``文件夹：``cd xxx``
- 返回上级文件夹：``cd ..``
- 创建文件夹：``mkdir [name]``
- 创建文件：``touch [name]``
- 删除：``rm[option][name]``
  - ``-r``递归删除一个目录
  - ``-f``强制删除
- 压缩与解压缩tar文件：``tar [option][name]`` （常用：``tar -xvf [name]``）
  - ``-x`` 解压
  - ``-c`` 选择多个目录/文件进行打包
  - ``-f [PACAGE_NAME]`` 指定打包后文件名
  - ``-z`` 压缩与解压缩``tar.gz``文件
  - ``-C [TARGET_DIR]`` 指导解压目录
- 编译C文件：``gcc [src] -o [dst]``

### 函数要求
在``bits.c``的文件开头，有对函数编写的相关要求：
- 遵循C语言规范，先声明全部局部变量再写表达式，否则评测时会报错。
- 若超出函数的最大操作符数量限制，会被扣除表现分。
- 除非有特殊要求，否则不能使用条件语句与循环语句。
- 除非有特殊要求，否则不能使用宏、调用其他函数或声明其他函数。
- 除非有特殊要求，否则不能使用结构、联合等``int``类型外的数据类型。
- 除非有特殊要求，否则不能使用强制类型转换。
- 除非有特殊要求，否则只能使用``!``，``~``,``|``,``&``,``+``,``^``,``<<``,``>>``操作符，部分题目可能有更严格的要求。
- 除非有特殊要求，否则只能使用0~255之间的整数。

### 如何测评
在将``bits.c``文件提交到AutoLab前，可以使用压缩包内提供的测评工具进行本地测评。

每次修改你的``bits.c``文件，在进行测评前，都需要在终端内输入``make``命令进行编译。

``btest``：在一个小的数据集上进行测试，不检查函数规范以及函数要求，不保证测评正确。
```
./btest -f [func]
# 对函数[func]进行测试
./btest -f [func] -1 7 -2 0xF
# 对函数[func]进行测试，第一个参数为7，第二个参数为0xF
```

``dlc``：用于检查你的代码是否符合规范
``./dlc bits.c``

``bddcheck``：在测试集上测试你的函数，检查是否能通过测试。
```
./bddcheck/check.pl -f [func]
# 对函数[func]进行完整测试
./bddcheck/check.pl 
# 对所有函数进行完整测试
```

``drivsr.pl``：对所有函数评分，运行上述三个测试器。
```
./driver.pl
```

### 一点提示
在动手之前，请牢记掩码、分治与浮点位表示的相关知识。

## 开始动手！
### bitOr
- 要求：仅使用 ``～`` 和 ``&`` 来实现 ``x | y``
- 允许的操作符：``~``、``&``
- 最大操作次数：8
- 分值：1
#### Solution
在离散数学中，学习过以下知识

$$ \sim ((\sim x) \And (\sim y))=x \mid y$$

因此得到以下代码：
```
int bitOr(int x, int y) {
  return ~((~x)&(~y));
}
```

### upperBits
- 要求：将32位二进制的高``n``位设置为1
- 允许的操作符：``!``、``~``、``&``、``^``、``|``、``+``、``<<``、``>>``
- 最大操作次数：10
- 参数范围：[0,32]
- 分值：1
#### Solution
要将这个数的高位设置为1，自然会联想到用``(1<<31)``进行算术右移。

答案呼之欲出：
```
int upperBits(int n) {
    return (1<<31)>>(n-1);
}
```
然后，就会遇到尴尬的情况：当``n=0``时，无法使用条件分支判断其存在，必须另寻他路。

我们尝试着考虑左移，那么就必须构造``-1``，并除去0的情况。

这里介绍一个之后题目常用的技巧，用``!!n``将非零数字转化为1，零不变。

产生一个掩码``mask``，若``n=0``时其为0，反之为1。

然后取``mask``的相反数，左移``(32-n)``位，就能得到答案。
```
int upperBits(int n) {
  int mask=!!n;
  return (~mask+1)<<(33+~n);
}
```

### fullAdd
- 要求：将``x+y``对16取模。
- 允许的操作符：``!``、``~``、``&``、``^``、``|``、``<<``、``>>``
- 最大操作次数：30
- 参数范围：[0,15]
- 分值：2
#### Solution